= AsciiDoc 介绍

AsciiDoc 是一门轻量级和语义化的纯文本标记语言，主要用于编写技术文档。该语言编写的文档可以被用于产生多种输出格式，所有的内容以一种简洁的，人类可读的纯文本格式编写。

AsciiDoc 跟它产生的输出格式是解耦的，AsciiDoc 处理器会解析一个 AsciiDoc 源文档并将解析的文档结构转化到一个或多个输出格式中（例如：HTML，PDF，EPUB3，manpage 或者 DocBook）。这个能力让它能够被用于静态网站生成器、IDEs、Git 工具、CI/CD 系统和其它软件中。

== 文档组成结构

接下来简单介绍 AsciiDoc 文档的组成结构。

=== 文档

AsciiDoc 是一种纯文本编写格式，一个 AsciiDoc 文档可以仅由一个句子甚至单个字符组成。

下面是仅有一个句子的一个段落（Paragraph）：
[,asciidoc]
----
This is a basic AsciiDoc document.
----
当然也可以有更多的句子。一个 AsciiDoc 文档是由一系列的块堆叠而成的，这些块通常由空行进行分隔。

要把上述样例中的一个段落扩展成两个，可以这样：
[,asciidoc]
----
This is a basic AsciiDoc document.

This document contains two paragraphs.
----
当然，文档也可以由一个文档头开始，虽然这个文档头是可选的，但它经常被使用，因为它允许你指定文档标题和设置一些文档级别的配置以及以文档属性存在的可重用文本。
[,asciidoc]
----
= Document Title
:reproducible:

This is a basic AsciiDoc document by {author}.

This document contains two paragraphs.
It also has a header that specifies the document title.
----

几乎任何块的组合都能构成文档（只要符合由文档类型决定的结构化要求）。

=== 行

行是 AsciiDoc 中的常见结构。一个行是由一个换行符或文档边界分隔的文本。许多语法会占用一整行。因此我们说 AsciiDoc 是面向行的语言。

例如，一个章节的标题必须自己占据一行，对于属性条目、块标题、块属性列表、块宏、列表条目、块分隔符等等都是如此。

一个章节标题必须占用一行：
[,asciidoc]
----
== Section Title
----

一个属性条目必须占用一行：
[,asciidoc]
----
:name: value
----

扩展到两行的属性条目：
[,asciidoc]
----
:name: value \
more value
----

空行同样也很重要，一个空行可以分隔标题和内容体。许多块也同样由一个空行分隔。

=== 块

块奠定了文档结构，一些块可能包含其它的块，所以文档结构是有层级的（一个树形结构）。块总是由一个新行开始，到行末结束，并与左边距对齐。

每个块可以有一行或多行块元数据，元数据可以是块属性、块锚点或块标题。这些元数据行必须直接出现在块的开始部分。

块可能会包含其它的块，而内嵌的块会从左边距开始。通过要求块从左边距开始，可以避免追踪和维护块的缩进层级，并让内容更加可重用。

=== 文本和内联元素

文本被标记、分隔符和元数据行包围。文本是一个文档的主要关注点。

文本可能会被替换，替换将标记解释为文本格式，用文本或非文本元素替换宏，展开属性引用，并执行其它类型的文本替换。

普通文本会被全部替换，除非特别声明，同样还可以进行最小化替换，还可以禁用替换，以将文本不替换直接原样输出。解析后的文本最终会变成内联元素和其他转换形式的混合。

== 文件编码

AsciiDoc 文件是一个 .adoc 扩展名的文本文件，许多 AsciiDoc 处理器会假设该文件使用 UTF-8 编码，仅当文件以 BOM 开头时才支持 UTF-16 编码。

AsciiDoc 处理器也能处理以一个字符串形式输入的 AsciiDoc，许多时候我们会将 AsciiDoc 保存到一个文件中。

== 关键概念

接下来是一些 AsciiDoc 关键概念的介绍。

=== 文档

文档表现为 AsciiDoc 中的顶级块元素，它由一个可选的文档头和一个或多个带有可选序言的章节，或者一个顶级块序列组成。

文档可以使用文档头进行配置，头本身不是块，而是文档的属性元数据，例如文档标题和文档属性。

=== 元素

一个元素是文档中一个可定位的，可寻址的，以及可组合的内容块。文档仅仅是它包含的所有元素的组合。

元素是类型的层次结构，一个元素可能是一系列元素的特化。例如，一个侧栏块是一个块元素，所以它跟所有的块元素一样共享特征，当然它也可以有自己的特征。

元素包括文档本身、章节、块、块宏，以及内联短语和宏。

一个块元素是垂直堆叠在其它块元素上面或下面的，块元素通常被简单地作为一个块引用。块构成了文档的主要树结构。

一个内联元素是一个块元素内的一段内容，或者是块中的属性之一（如：一个块标题）。内联元素包括格式化文本（如：斜体，粗体等）、内联宏和元素引用，填充这些元素的文本不会被替换。

=== 属性

一个属性是一个键值对，用于存储和描述 AsciiDoc 中的元数据。属性可以影响语法，控制行为，自定义样式，激活或配置某些功能，或者存储内联替换内容。属性将 AsciiDoc 与其它的轻量级标记语言区分开来。

属性其实是一个抽象的术语，有两种具体的分类：文档属性和元素属性。

==== 文档属性

直接跟文档关联的属性，被用于在运行时暴露文档的信息，控制处理器的行为，存储可重用的值或短语。因此，它们是与处理器进行双向通信的信道。

文档属性可以使用属性引用在正文中引用（不管属性替换是否开启），文档属性可以在文档中使用属性条目定义，也可以通过 CLI 或 API 定义，不是所有的文档属性都可以被修改。

==== 元素属性

元素属性是在特定元素上的元数据，比如一个块或者内联元素，它们被定义在一个属性列表中并且只能应用到那个元素。属性名可以是一个字符串，也可以是一个隐式数字索引（一个未命名的位置属性）。

不像文档属性，元素属性不能直接在正文中引用，元素属性丰富或配置元素的行为，如应用一个角色或设置一个图片的宽度。元素属性定义在一个元素的属性列表上，或者以块标题行这样的简写形式出现。

=== 宏

宏是一种用于表示非文本元素或将提供的元数据展开成文本的一种语法。

这是一个宏的示例：
[,asciidoc]
----
image::sunset.jpg[Sunset]
----

这是一个内联宏的示例：
[,asciidoc]
----
Click the button with the image:star.png[Star] to favorite the project.
----

可以将宏想象成函数，宏语法以一个名称，一个可选的目标，加上一个由方括号括起来的零个或多个属性的属性列表的形式出现。

宏有两种两种变体：块宏和内联宏。块宏中，名称和目标由两个冒号（::）分隔，并且它必须自己独占一行。而在内联宏中，名称和目标由一个冒号（:）分隔，并且它可以跟文本和其它的内联元素在同一行。块宏总是会被解析，而内联宏仅当宏替换启用时才会被解析。

=== 预处理器指令

AsciiDoc 中还有一种看起来很像块宏的语法，但并不是宏，它就是预处理器指令。

预处理器指令是一个函数，它控制送入解析器的行。一个条件化的预处理器指令可以根据属性（ifdef，ifndef）或其它任意条件（ifeval）配置行被包含还是排除。一个 include 指令可以从其它文档添加额外的行到文档中。

预处理器指令跟块宏共享常见的特性，跟块宏一样，预处理器指令必须独占一行。虽然它可以访问文档属性，但是它无法感知它周围的上下文，它只是一个行处理器。include 指令可以有元素属性，虽然属性只能应用到预处理器操作本身。

== 文档处理

AsciiDoc 特指一种书写格式，而不是一种发布格式，也就是说它并不是所见即所得的，用 AsciiDoc 编写的文件需要用一个 AsciiDoc 处理器（如：Asciidoctor）将 AsciiDoc 源文件转化成一种可以发布的格式。

将 AsciiDoc 源文件转化成另一种格式的文件这件事是由转换器（converter） 来实现的，虽然在语言和转换器之间有很强的关系，但这两方面没有明确耦合。

AsciiDoc 处理器提供了几种内建的转化器，包括 HTML 和 DocBook。要启用这些转化器中的一个，需要设置文档的后端（backend，就是一种转化器输出格式的标识，默认是 html）。这个后端会告诉处理器需要产生的输出格式，而处理器会根据这个信息选择合适的转化器生成对应的输出格式。如，HTML 转化器会处理后端为 html 的文档转化请求，将 AsciiDoc 文档转化成 HTML 格式的输出。

AsciiDoc 处理器的工作主要分为两步：首先，它会解析 AsciiDoc 文档，解析之后会产生一种反应文档结构的结构化文档，并解释所有的有意义的标记。之后，处理器会将这个结构化文档传递给转化器，转化器会负责转换成用户期望的格式（即：backend 的值）输出。

== 规范化

当 AsciiDoc 处理器读取 AsciiDoc 源文件后，第一件事就是将所有的行规范化（这个操作可以是在其它操作之前对所有行一次性全部执行，也可以是对每一行进行访问的时候再执行）。

.规范化操作由如下操作组成：
* 强制所有的文本编码为 UTF-8
* 将每一行的换行符及尾随空格去掉

规范化的执行独立于任何的结构化上下文。一个行是一个文本块还是一个常规段落的一部分并不重要，所有的行都会被规范化。

对于被包含的文件中的行，规范化只会在某些情况下被执行，即该文件有一个可以被识别的 AsciiDoc 文件扩展名时，而对于其它文件，仅会移除换行符。被包含的文件也可以有不同的编码，由编码属性指定，如果没有指定，则处理器会假设编码为 UTF-8。

当处理器将多个行组合在一起以产生输出文档（HTML、DocBook 等）时，会在换行符上将这些行连接起来。
